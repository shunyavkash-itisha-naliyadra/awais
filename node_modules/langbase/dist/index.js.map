{"version":3,"sources":["../src/index.ts","../src/lib/utils/doc-to-formdata.ts","../src/data/constants.ts","../src/common/errors.ts","../src/common/stream.ts","../src/common/request.ts","../src/langbase/langbase.ts","../src/pipes/pipes.ts","../src/lib/helpers/index.ts"],"sourcesContent":["export * from './langbase/langbase';\nexport * from './pipes/pipes';\nexport * from './lib/helpers'\n","\n/**\n * Converts various document formats to FormData.\n *\n * @param options - The conversion options\n * @param options.document - The document to convert. Can be Buffer, File, FormData or ReadableStream\n * @param options.documentName - The name of the document\n * @param options.contentType - The MIME type of the document\n *\n * @returns A Promise that resolves to FormData containing the document\n *\n * @example\n * ```ts\n * const buffer = Buffer.from('Hello World');\n * const formData = await convertDocToFormData({\n *   document: buffer,\n *   documentName: 'hello.txt',\n *   contentType: 'text/plain'\n * });\n * ```\n */\nexport async function convertDocToFormData(options: {\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tdocumentName: string;\n\tcontentType: string;\n}) {\n\tlet formData = new FormData();\n\n\tif (options.document instanceof Buffer) {\n\t\tconst documentBlob = new Blob([options.document], {\n\t\t\ttype: options.contentType,\n\t\t});\n\t\tformData.append('document', documentBlob, options.documentName);\n\t} else if (options.document instanceof File) {\n\t\tformData.append('document', options.document, options.documentName);\n\t} else if (options.document instanceof FormData) {\n\t\tformData = options.document;\n\t} else if (options.document instanceof ReadableStream) {\n\t\tconst chunks: Uint8Array[] = [];\n\t\tconst reader = options.document.getReader();\n\n\t\twhile (true) {\n\t\t\tconst {done, value} = await reader.read();\n\t\t\tif (done) break;\n\t\t\tchunks.push(value);\n\t\t}\n\n\t\tconst documentBlob = new Blob(chunks, {type: options.contentType});\n\t\tformData.append('document', documentBlob, options.documentName);\n\t}\n\n\tformData.append('documentName', options.documentName);\n\n\treturn formData;\n}\n","export const GENERATION_ENDPOINTS = [\n\t'/v1/pipes/run',\n\t'/beta/chat',\n\t'/beta/generate',\n]\n","import {Headers} from './../../types'; // Ensure this import is correct\n\nexport class APIError extends Error {\n\treadonly status: number | undefined;\n\treadonly headers: Headers | undefined;\n\treadonly error: Object | undefined;\n\n\treadonly code: string | null | undefined;\n\treadonly param: string | null | undefined;\n\treadonly type: string | undefined;\n\n\treadonly request_id: string | null | undefined;\n\n\tconstructor(\n\t\tstatus: number | undefined,\n\t\terror: Object | undefined,\n\t\tmessage: string | undefined,\n\t\theaders: Headers | undefined,\n\t) {\n\t\tsuper(APIError.makeMessage(status, error, message));\n\t\tthis.status = status;\n\t\tthis.headers = headers;\n\t\tthis.request_id = headers?.['lb-request-id'];\n\n\t\tconst data = error as Record<string, any>;\n\t\tthis.error = data;\n\t\tthis.code = data?.['code'];\n\t\tthis.status = data?.['status'];\n\t\t// this.param = data?.['param'];\n\t\t// this.type = data?.['type'];\n\t}\n\n\tprivate static makeMessage(\n\t\tstatus: number | undefined,\n\t\terror: any,\n\t\tmessage: string | undefined,\n\t): string {\n\t\tconst msg = error?.message\n\t\t\t? typeof error.message === 'string'\n\t\t\t\t? error.message\n\t\t\t\t: JSON.stringify(error.message)\n\t\t\t: error\n\t\t\t\t? JSON.stringify(error)\n\t\t\t\t: message;\n\n\t\tif (status && msg) {\n\t\t\treturn `${status} ${msg}`;\n\t\t}\n\t\tif (status) {\n\t\t\treturn `${status} status code (no body)`;\n\t\t}\n\t\tif (msg) {\n\t\t\treturn msg;\n\t\t}\n\t\treturn '(no status code or body)';\n\t}\n\n\tstatic generate(\n\t\tstatus: number | undefined,\n\t\terrorResponse: Object | undefined,\n\t\tmessage: string | undefined,\n\t\theaders: Headers | undefined,\n\t): APIError {\n\t\tif (!status) {\n\t\t\treturn new APIConnectionError({\n\t\t\t\tcause:\n\t\t\t\t\terrorResponse instanceof Error ? errorResponse : undefined,\n\t\t\t});\n\t\t}\n\n\t\tconst error = (errorResponse as Record<string, any>)?.['error'];\n\n\t\tswitch (status) {\n\t\t\tcase 400:\n\t\t\t\treturn new BadRequestError(status, error, message, headers);\n\t\t\tcase 401:\n\t\t\t\treturn new AuthenticationError(status, error, message, headers);\n\t\t\tcase 403:\n\t\t\t\treturn new PermissionDeniedError(\n\t\t\t\t\tstatus,\n\t\t\t\t\terror,\n\t\t\t\t\tmessage,\n\t\t\t\t\theaders,\n\t\t\t\t);\n\t\t\tcase 404:\n\t\t\t\treturn new NotFoundError(status, error, message, headers);\n\t\t\tcase 409:\n\t\t\t\treturn new ConflictError(status, error, message, headers);\n\t\t\tcase 422:\n\t\t\t\treturn new UnprocessableEntityError(\n\t\t\t\t\tstatus,\n\t\t\t\t\terror,\n\t\t\t\t\tmessage,\n\t\t\t\t\theaders,\n\t\t\t\t);\n\t\t\tcase 429:\n\t\t\t\treturn new RateLimitError(status, error, message, headers);\n\t\t\tdefault:\n\t\t\t\treturn status >= 500\n\t\t\t\t\t? new InternalServerError(status, error, message, headers)\n\t\t\t\t\t: new APIError(status, error, message, headers);\n\t\t}\n\t}\n}\n\nexport class APIConnectionError extends APIError {\n\toverride readonly status: undefined = undefined;\n\n\tconstructor({message, cause}: {message?: string; cause?: Error}) {\n\t\tsuper(undefined, undefined, message || 'Connection error.', undefined);\n\t\tif (cause) (this as Error).cause = cause;\n\t}\n}\n\nexport class APIConnectionTimeoutError extends APIConnectionError {\n\tconstructor({message}: {message?: string} = {}) {\n\t\tsuper({message: message ?? 'Request timed out.'});\n\t}\n}\n\nexport class BadRequestError extends APIError {\n\toverride readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends APIError {\n\toverride readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends APIError {\n\toverride readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends APIError {\n\toverride readonly status: 404 = 404;\n}\n\nexport class ConflictError extends APIError {\n\toverride readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends APIError {\n\toverride readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends APIError {\n\toverride readonly status: 429 = 429;\n}\n\nexport class InternalServerError extends APIError {}\n","type Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n\tevent: string | null;\n\tdata: string;\n\traw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n\tcontroller: AbortController;\n\n\tconstructor(\n\t\tprivate iterator: () => AsyncIterator<Item>,\n\t\tcontroller: AbortController,\n\t) {\n\t\tthis.controller = controller;\n\t}\n\n\t/**\n\t * Creates a stream of AsyncIterator from a Server-Sent Events (SSE) response.\n\t *\n\t * @template Item - The type of items in the stream.\n\t * @param {Response} response - The SSE response object.\n\t * @param {AbortController} controller - The abort controller used to cancel the ongoing request.\n\t * @returns {Stream<AsyncIterator<Item, any, undefined>>} - The stream created from the SSE response.\n\t * @throws {Error} - If the stream has already been consumed.\n\t */\n\tstatic fromSSEResponse<Item>(\n\t\tresponse: Response,\n\t\tcontroller: AbortController,\n\t) {\n\t\tlet consumed = false;\n\n\t\tasync function* iterator(): AsyncIterator<Item, any, undefined> {\n\t\t\tif (consumed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot iterate over a consumed stream, use `.tee()` to split the stream.',\n\t\t\t\t);\n\t\t\t}\n\t\t\tconsumed = true;\n\t\t\tlet done = false;\n\t\t\ttry {\n\t\t\t\tfor await (const sse of _iterSSEMessages(\n\t\t\t\t\tresponse,\n\t\t\t\t\tcontroller,\n\t\t\t\t)) {\n\t\t\t\t\tif (done) continue;\n\n\t\t\t\t\tif (sse.data.startsWith('[DONE]')) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sse.event === null) {\n\t\t\t\t\t\tlet data;\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = JSON.parse(sse.data);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`Could not parse message into JSON:`,\n\t\t\t\t\t\t\t\tsse.data,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconsole.error(`From chunk:`, sse.raw);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (data && data.error) {\n\t\t\t\t\t\t\tthrow new Error(data.error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tyield data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet data;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = JSON.parse(sse.data);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t\t`Could not parse message into JSON:`,\n\t\t\t\t\t\t\t\tsse.data,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconsole.error(`From chunk:`, sse.raw);\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: Is this where the error should be thrown?\n\t\t\t\t\t\tif (sse.event == 'error') {\n\t\t\t\t\t\t\tthrow new Error(data.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tyield {event: sse.event, data: data} as any;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t} catch (e) {\n\t\t\t\t// If the user calls `stream.controller.abort()`, we should exit without throwing.\n\t\t\t\tif (e instanceof Error && e.name === 'AbortError') return;\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\t// If the user `break`s, abort the ongoing request.\n\t\t\t\tif (!done) controller.abort();\n\t\t\t}\n\t\t}\n\n\t\treturn new Stream(iterator, controller);\n\t}\n\n\t/**\n\t * Generates a Stream from a newline-separated ReadableStream\n\t * where each item is a JSON value.\n\t *\n\t * @template Item - The type of items in the stream.\n\t * @param {ReadableStream} readableStream - The readable stream to create the stream from.\n\t * @param {AbortController} controller - The abort controller to control the stream.\n\t * @returns {Stream<Item>} - The created stream.\n\t */\n\tstatic fromReadableStream<Item>(\n\t\treadableStream: ReadableStream,\n\t\tcontroller: AbortController,\n\t) {\n\t\tlet consumed = false;\n\n\t\tasync function* iterLines(): AsyncGenerator<string, void, unknown> {\n\t\t\tconst lineDecoder = new LineDecoder();\n\n\t\t\tconst iter = readableStreamAsyncIterable<Bytes>(readableStream);\n\t\t\tfor await (const chunk of iter) {\n\t\t\t\tfor (const line of lineDecoder.decode(chunk)) {\n\t\t\t\t\tyield line;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const line of lineDecoder.flush()) {\n\t\t\t\tyield line;\n\t\t\t}\n\t\t}\n\n\t\tasync function* iterator(): AsyncIterator<Item, any, undefined> {\n\t\t\tif (consumed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot iterate over a consumed stream, use `.tee()` to split the stream.',\n\t\t\t\t);\n\t\t\t}\n\t\t\tconsumed = true;\n\t\t\tlet done = false;\n\t\t\ttry {\n\t\t\t\tfor await (const line of iterLines()) {\n\t\t\t\t\tif (done) continue;\n\t\t\t\t\tif (line) yield JSON.parse(line);\n\t\t\t\t}\n\t\t\t\tdone = true;\n\t\t\t} catch (e) {\n\t\t\t\t// If the user calls `stream.controller.abort()`, we should exit without throwing.\n\t\t\t\tif (e instanceof Error && e.name === 'AbortError') return;\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\t// If the user `break`s, abort the ongoing request.\n\t\t\t\tif (!done) controller.abort();\n\t\t\t}\n\t\t}\n\n\t\treturn new Stream(iterator, controller);\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<Item> {\n\t\treturn this.iterator();\n\t}\n\n\t/**\n\t * Splits the stream into two streams which can be\n\t * independently read from at different speeds.\n\t */\n\ttee(): [Stream<Item>, Stream<Item>] {\n\t\tconst left: Array<Promise<IteratorResult<Item>>> = [];\n\t\tconst right: Array<Promise<IteratorResult<Item>>> = [];\n\t\tconst iterator = this.iterator();\n\n\t\tconst teeIterator = (\n\t\t\tqueue: Array<Promise<IteratorResult<Item>>>,\n\t\t): AsyncIterator<Item> => {\n\t\t\treturn {\n\t\t\t\tnext: () => {\n\t\t\t\t\tif (queue.length === 0) {\n\t\t\t\t\t\tconst result = iterator.next();\n\t\t\t\t\t\tleft.push(result);\n\t\t\t\t\t\tright.push(result);\n\t\t\t\t\t}\n\t\t\t\t\treturn queue.shift()!;\n\t\t\t\t},\n\t\t\t};\n\t\t};\n\n\t\treturn [\n\t\t\tnew Stream(() => teeIterator(left), this.controller),\n\t\t\tnew Stream(() => teeIterator(right), this.controller),\n\t\t];\n\t}\n\n\t/**\n\t * Converts this stream to a newline-separated ReadableStream of\n\t * JSON stringified values in the stream which can be turned back into a Stream with `Stream.fromReadableStream()`.\n\t */\n\ttoReadableStream(): ReadableStream {\n\t\tconst self = this;\n\t\tlet iter: AsyncIterator<Item>;\n\t\tconst encoder = new TextEncoder();\n\n\t\treturn new ReadableStream({\n\t\t\tasync start() {\n\t\t\t\titer = self[Symbol.asyncIterator]();\n\t\t\t},\n\t\t\tasync pull(ctrl: any) {\n\t\t\t\ttry {\n\t\t\t\t\tconst {value, done} = await iter.next();\n\t\t\t\t\tif (done) return ctrl.close();\n\n\t\t\t\t\tconst bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n\t\t\t\t\tctrl.enqueue(bytes);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tctrl.error(err);\n\t\t\t\t}\n\t\t\t},\n\t\t\tasync cancel() {\n\t\t\t\tawait iter.return?.();\n\t\t\t},\n\t\t});\n\t}\n}\n\n/**\n * Asynchronously iterates over Server-Sent Event (SSE) messages from a response body.\n *\n * @param response - The response object containing the SSE messages.\n * @param controller - The AbortController used to abort the iteration if needed.\n * @returns An async generator that yields ServerSentEvent objects.\n * @throws Error if the response has no body.\n */\nexport async function* _iterSSEMessages(\n\tresponse: Response,\n\tcontroller: AbortController,\n): AsyncGenerator<ServerSentEvent, void, unknown> {\n\tif (!response.body) {\n\t\tcontroller.abort();\n\t\tthrow new Error(`Attempted to iterate over a response with no body`);\n\t}\n\n\tconst sseDecoder = new SSEDecoder();\n\tconst lineDecoder = new LineDecoder();\n\n\tconst iter = readableStreamAsyncIterable<Bytes>(response.body);\n\tfor await (const sseChunk of iterSSEChunks(iter)) {\n\t\tfor (const line of lineDecoder.decode(sseChunk)) {\n\t\t\tconst sse = sseDecoder.decode(line);\n\t\t\tif (sse) yield sse;\n\t\t}\n\t}\n\n\tfor (const line of lineDecoder.flush()) {\n\t\tconst sse = sseDecoder.decode(line);\n\t\tif (sse) yield sse;\n\t}\n}\n\n/**\n * Asynchronously iterates over SSE (Server-Sent Events) chunks and yields the data as Uint8Array.\n *\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n *\n * @param iterator - The async iterator that provides the SSE chunks.\n * @returns An async generator that yields Uint8Array chunks.\n */\nasync function* iterSSEChunks(\n\titerator: AsyncIterableIterator<Bytes>,\n): AsyncGenerator<Uint8Array> {\n\tlet data = new Uint8Array();\n\n\tfor await (const chunk of iterator) {\n\t\tif (chunk == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst binaryChunk =\n\t\t\tchunk instanceof ArrayBuffer\n\t\t\t\t? new Uint8Array(chunk)\n\t\t\t\t: typeof chunk === 'string'\n\t\t\t\t\t? new TextEncoder().encode(chunk)\n\t\t\t\t\t: chunk;\n\n\t\tlet newData = new Uint8Array(data.length + binaryChunk.length);\n\t\tnewData.set(data);\n\t\tnewData.set(binaryChunk, data.length);\n\t\tdata = newData;\n\n\t\tlet patternIndex;\n\t\twhile ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n\t\t\tyield data.slice(0, patternIndex);\n\t\t\tdata = data.slice(patternIndex);\n\t\t}\n\t}\n\n\tif (data.length > 0) {\n\t\tyield data;\n\t}\n}\n\n/**\n * Finds the index of the first occurrence of a double newline pattern (\\r\\r, \\n\\n, \\r\\n\\r\\n) in the given buffer.\n *\n * @param buffer - The buffer to search for the double newline pattern.\n * @returns The index right after the first occurrence of the double newline pattern, or -1 if not found.\n */\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\n\t// This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n\t// and returns the index right after the first occurrence of any pattern,\n\t// or -1 if none of the patterns are found.\n\tconst newline = 0x0a; // \\n\n\tconst carriage = 0x0d; // \\r\n\n\tfor (let i = 0; i < buffer.length - 2; i++) {\n\t\tif (buffer[i] === newline && buffer[i + 1] === newline) {\n\t\t\t// \\n\\n\n\t\t\treturn i + 2;\n\t\t}\n\t\tif (buffer[i] === carriage && buffer[i + 1] === carriage) {\n\t\t\t// \\r\\r\n\t\t\treturn i + 2;\n\t\t}\n\t\tif (\n\t\t\tbuffer[i] === carriage &&\n\t\t\tbuffer[i + 1] === newline &&\n\t\t\ti + 3 < buffer.length &&\n\t\t\tbuffer[i + 2] === carriage &&\n\t\t\tbuffer[i + 3] === newline\n\t\t) {\n\t\t\t// \\r\\n\\r\\n\n\t\t\treturn i + 4;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Represents a Server-Sent Event (SSE) decoder.\n */\nclass SSEDecoder {\n\tprivate data: string[];\n\tprivate event: string | null;\n\tprivate chunks: string[];\n\n\tconstructor() {\n\t\tthis.event = null;\n\t\tthis.data = [];\n\t\tthis.chunks = [];\n\t}\n\n\t/**\n\t * Decodes a line of text and returns a ServerSentEvent object if a complete event is found.\n\t * @param line - The line of text to decode.\n\t * @returns A ServerSentEvent object if a complete event is found, otherwise null.\n\t */\n\tdecode(line: string) {\n\t\tif (line.endsWith('\\r')) {\n\t\t\tline = line.substring(0, line.length - 1);\n\t\t}\n\n\t\tif (!line) {\n\t\t\t// empty line and we didn't previously encounter any messages\n\t\t\tif (!this.event && !this.data.length) return null;\n\n\t\t\tconst sse: ServerSentEvent = {\n\t\t\t\tevent: this.event,\n\t\t\t\tdata: this.data.join('\\n'),\n\t\t\t\traw: this.chunks,\n\t\t\t};\n\n\t\t\tthis.event = null;\n\t\t\tthis.data = [];\n\t\t\tthis.chunks = [];\n\n\t\t\treturn sse;\n\t\t}\n\n\t\tthis.chunks.push(line);\n\n\t\tif (line.startsWith(':')) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet [fieldname, _, value] = partition(line, ':');\n\n\t\tif (value.startsWith(' ')) {\n\t\t\tvalue = value.substring(1);\n\t\t}\n\n\t\tif (fieldname === 'event') {\n\t\t\tthis.event = value;\n\t\t} else if (fieldname === 'data') {\n\t\t\tthis.data.push(value);\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n\t// prettier-ignore\n\tstatic NEWLINE_CHARS = new Set(['\\n', '\\r']);\n\tstatic NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n\n\tbuffer: string[];\n\ttrailingCR: boolean;\n\ttextDecoder: any; // TextDecoder found in browsers; not typed to avoid pulling in either \"dom\" or \"node\" types.\n\n\tconstructor() {\n\t\tthis.buffer = [];\n\t\tthis.trailingCR = false;\n\t}\n\n\tdecode(chunk: Bytes): string[] {\n\t\tlet text = this.decodeText(chunk);\n\n\t\tif (this.trailingCR) {\n\t\t\ttext = '\\r' + text;\n\t\t\tthis.trailingCR = false;\n\t\t}\n\t\tif (text.endsWith('\\r')) {\n\t\t\tthis.trailingCR = true;\n\t\t\ttext = text.slice(0, -1);\n\t\t}\n\n\t\tif (!text) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst trailingNewline = LineDecoder.NEWLINE_CHARS.has(\n\t\t\ttext[text.length - 1] || '',\n\t\t);\n\t\tlet lines = text.split(LineDecoder.NEWLINE_REGEXP);\n\n\t\t// if there is a trailing new line then the last entry will be an empty\n\t\t// string which we don't care about\n\t\tif (trailingNewline) {\n\t\t\tlines.pop();\n\t\t}\n\n\t\tif (lines.length === 1 && !trailingNewline) {\n\t\t\tthis.buffer.push(lines[0]!);\n\t\t\treturn [];\n\t\t}\n\n\t\tif (this.buffer.length > 0) {\n\t\t\tlines = [this.buffer.join('') + lines[0], ...lines.slice(1)];\n\t\t\tthis.buffer = [];\n\t\t}\n\n\t\tif (!trailingNewline) {\n\t\t\tthis.buffer = [lines.pop() || ''];\n\t\t}\n\n\t\treturn lines;\n\t}\n\n\tdecodeText(bytes: Bytes): string {\n\t\tif (bytes == null) return '';\n\t\tif (typeof bytes === 'string') return bytes;\n\n\t\t// Node:\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\tif (bytes instanceof Buffer) {\n\t\t\t\treturn bytes.toString();\n\t\t\t}\n\t\t\tif (bytes instanceof Uint8Array) {\n\t\t\t\treturn Buffer.from(bytes).toString();\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global \"Buffer\" defined, which this library assumes to be Node. Please report this error.`,\n\t\t\t);\n\t\t}\n\n\t\t// Browser\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\tif (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {\n\t\t\t\tthis.textDecoder ??= new TextDecoder('utf8');\n\t\t\t\treturn this.textDecoder.decode(bytes);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Unexpected: received non-Uint8Array/ArrayBuffer (${\n\t\t\t\t\t(bytes as any).constructor.name\n\t\t\t\t}) in a web platform. Please report this error.`,\n\t\t\t);\n\t\t}\n\n\t\tthrow new Error(\n\t\t\t`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`,\n\t\t);\n\t}\n\n\tflush(): string[] {\n\t\tif (!this.buffer.length && !this.trailingCR) {\n\t\t\treturn [];\n\t\t}\n\n\t\tconst lines = [this.buffer.join('')];\n\t\tthis.buffer = [];\n\t\tthis.trailingCR = false;\n\t\treturn lines;\n\t}\n}\n\n/**\n * Decodes an array of chunks into an array of lines.\n *\n * This is an internal helper function that's just used for testing\n *\n * @param chunks - An array of chunks to decode.\n * @returns An array of decoded lines.\n */\nexport function _decodeChunks(chunks: string[]): string[] {\n\tconst decoder = new LineDecoder();\n\tconst lines: string[] = [];\n\tfor (const chunk of chunks) {\n\t\tlines.push(...decoder.decode(chunk));\n\t}\n\n\treturn lines;\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n\tconst index = str.indexOf(delimiter);\n\tif (index !== -1) {\n\t\treturn [\n\t\t\tstr.substring(0, index),\n\t\t\tdelimiter,\n\t\t\tstr.substring(index + delimiter.length),\n\t\t];\n\t}\n\n\treturn [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(\n\tstream: any,\n): AsyncIterableIterator<T> {\n\tif (stream[Symbol.asyncIterator]) return stream;\n\n\tconst reader = stream.getReader();\n\treturn {\n\t\tasync next() {\n\t\t\ttry {\n\t\t\t\tconst result = await reader.read();\n\t\t\t\tif (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\treader.releaseLock(); // release lock when stream becomes errored\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t},\n\t\tasync return() {\n\t\t\tconst cancelPromise = reader.cancel();\n\t\t\treader.releaseLock();\n\t\t\tawait cancelPromise;\n\t\t\treturn {done: true, value: undefined};\n\t\t},\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t};\n}\n","import {GENERATION_ENDPOINTS} from '@/data/constants';\nimport {Headers} from './../../types'; // Ensure this import is correct\nimport {APIConnectionError, APIError} from './errors';\nimport {Stream} from './stream';\n\ninterface RequestOptions {\n\tendpoint: string;\n\tmethod: string;\n\theaders?: Headers;\n\tbody?: any;\n\tstream?: boolean;\n}\n\ninterface RequestConfig {\n\tapiKey: string;\n\tbaseUrl: string;\n\ttimeout?: number;\n}\n\ninterface SendOptions extends RequestOptions {\n\tendpoint: string;\n}\n\ninterface MakeRequestParams {\n\turl: string;\n\toptions: RequestOptions;\n\theaders: Record<string, string>;\n}\n\ninterface HandleGenerateResponseParams {\n\tresponse: Response;\n\tthreadId: string | null;\n\trawResponse: boolean;\n}\n\nexport class Request {\n\tprivate config: RequestConfig;\n\n\tconstructor(config: RequestConfig) {\n\t\tthis.config = config;\n\t}\n\n\t// Main send function\n\tprivate async send<T>({endpoint, ...options}: SendOptions): Promise<T> {\n\t\tconst url = this.buildUrl({endpoint});\n\t\tconst headers = this.buildHeaders({headers: options.headers});\n\n\t\tlet response: Response;\n\t\ttry {\n\t\t\tresponse = await this.makeRequest({url, options, headers});\n\t\t} catch (error) {\n\t\t\tthrow new APIConnectionError({\n\t\t\t\tcause: error instanceof Error ? error : undefined,\n\t\t\t});\n\t\t}\n\n\t\tif (!response.ok) {\n\t\t\tawait this.handleErrorResponse({response});\n\t\t}\n\n\t\tconst isLllmGenerationEndpoint =\n\t\t\tGENERATION_ENDPOINTS.includes(endpoint);\n\n\t\tif (isLllmGenerationEndpoint) {\n\t\t\tconst threadId = response.headers.get('lb-thread-id');\n\n\t\t\tif (!options.body) {\n\t\t\t\treturn this.handleRunResponse({\n\t\t\t\t\tresponse,\n\t\t\t\t\tthreadId: null,\n\t\t\t\t\trawResponse: options.body?.rawResponse ?? false,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (options.body?.stream && url.includes('run')) {\n\t\t\t\treturn this.handleRunResponseStream({\n\t\t\t\t\tresponse,\n\t\t\t\t\trawResponse: options.body.rawResponse,\n\t\t\t\t}) as T;\n\t\t\t}\n\n\t\t\tif (options.body.stream) {\n\t\t\t\treturn this.handleStreamResponse({response}) as T;\n\t\t\t}\n\n\t\t\treturn this.handleRunResponse({\n\t\t\t\tresponse,\n\t\t\t\tthreadId,\n\t\t\t\trawResponse: options.body?.rawResponse ?? false,\n\t\t\t});\n\t\t} else {\n\t\t\tconst res = response.json();\n\t\t\treturn res as T;\n\t\t}\n\t}\n\n\tprivate buildUrl({endpoint}: {endpoint: string}): string {\n\t\treturn `${this.config.baseUrl}${endpoint}`;\n\t}\n\n\tprivate buildHeaders({\n\t\theaders,\n\t}: {\n\t\theaders?: Record<string, string>;\n\t}): Record<string, string> {\n\t\treturn {\n\t\t\t'Content-Type': 'application/json',\n\t\t\tAuthorization: `Bearer ${this.config.apiKey}`,\n\t\t\t...headers,\n\t\t};\n\t}\n\n\tprivate async makeRequest({\n\t\turl,\n\t\toptions,\n\t\theaders,\n\t}: MakeRequestParams): Promise<Response> {\n\t\treturn fetch(url, {\n\t\t\tmethod: options.method,\n\t\t\theaders,\n\t\t\tbody: JSON.stringify(options.body),\n\t\t\t// signal: AbortSignal.timeout(this.config.timeout || 30000),\n\t\t});\n\t}\n\n\tprivate async handleErrorResponse({\n\t\tresponse,\n\t}: {\n\t\tresponse: Response;\n\t}): Promise<never> {\n\t\tlet errorBody;\n\t\ttry {\n\t\t\terrorBody = await response.json();\n\t\t} catch {\n\t\t\terrorBody = await response.text();\n\t\t}\n\t\tthrow APIError.generate(\n\t\t\tresponse.status,\n\t\t\terrorBody,\n\t\t\tresponse.statusText,\n\t\t\tresponse.headers as unknown as Headers,\n\t\t);\n\t}\n\n\tprivate handleStreamResponse({response}: {response: Response}): {\n\t\tstream: any;\n\t\tthreadId: string | null;\n\t} {\n\t\tconst controller = new AbortController();\n\t\tconst stream = Stream.fromSSEResponse(response, controller);\n\t\treturn {stream, threadId: response.headers.get('lb-thread-id')};\n\t}\n\n\tprivate handleRunResponseStream({\n\t\tresponse,\n\t\trawResponse,\n\t}: {\n\t\tresponse: Response;\n\t\trawResponse?: boolean;\n\t}): {\n\t\tstream: any;\n\t\tthreadId: string | null;\n\t\trawResponse?: {\n\t\t\theaders: Record<string, string>;\n\t\t};\n\t} {\n\t\tconst controller = new AbortController();\n\t\tconst streamSSE = Stream.fromSSEResponse(response, controller);\n\t\tconst stream = streamSSE.toReadableStream();\n\n\t\tconst result: {\n\t\t\tstream: ReadableStream<any>;\n\t\t\tthreadId: string | null;\n\t\t\trawResponse?: {\n\t\t\t\theaders: Record<string, string>;\n\t\t\t};\n\t\t} = {\n\t\t\tstream,\n\t\t\tthreadId: response.headers.get('lb-thread-id'),\n\t\t};\n\t\tif (rawResponse) {\n\t\t\tresult.rawResponse = {\n\t\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t\t};\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate async handleRunResponse({\n\t\tresponse,\n\t\tthreadId,\n\t\trawResponse,\n\t}: HandleGenerateResponseParams): Promise<any> {\n\t\tconst generateResponse = await response.json();\n\n\t\tconst buildResponse = generateResponse.raw\n\t\t\t? {\n\t\t\t\t\tcompletion: generateResponse.completion,\n\t\t\t\t\t...generateResponse.raw,\n\t\t\t\t}\n\t\t\t: generateResponse;\n\n\t\tconst result: any = {\n\t\t\t...buildResponse,\n\t\t};\n\n\t\tif (threadId) {\n\t\t\tresult.threadId = threadId;\n\t\t}\n\n\t\tif (rawResponse) {\n\t\t\tresult.rawResponse = {\n\t\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tasync post<T>(options: Omit<RequestOptions, 'method'>): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'POST'});\n\t}\n\n\tasync get<T>(options: Omit<RequestOptions, 'method' | 'body'>): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'GET'});\n\t}\n\n\tasync put<T>(options: Omit<RequestOptions, 'method'>): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'PUT'});\n\t}\n\n\tasync delete<T>(\n\t\toptions: Omit<RequestOptions, 'method' | 'body'>,\n\t): Promise<T> {\n\t\treturn this.send<T>({...options, method: 'DELETE'});\n\t}\n}\n","import {convertDocToFormData} from '@/lib/utils/doc-to-formdata';\nimport {Request} from '../common/request';\n\nexport type Role = 'user' | 'assistant' | 'system' | 'tool';\n\nexport interface RunOptionsBase {\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tthreadId?: string;\n\trawResponse?: boolean;\n\trunTools?: boolean;\n\ttools?: Tools[];\n\tname?: string; // Pipe name for SDK,\n\tapiKey?: string; // pipe level key for SDK\n\tllmKey?: string; // LLM API key\n\tjson?: boolean;\n}\n\nexport interface RunOptionsT extends RunOptionsBase {\n\tstream?: false;\n}\n\nexport interface RunOptionsStreamT extends RunOptionsBase {\n\tstream: true;\n}\n\ninterface ChoiceGenerate {\n\tindex: number;\n\tmessage: Message;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\nexport interface Usage {\n\tprompt_tokens: number;\n\tcompletion_tokens: number;\n\ttotal_tokens: number;\n}\n\nexport interface RunResponse {\n\tcompletion: string;\n\tthreadId?: string;\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceGenerate[];\n\tusage: Usage;\n\tsystem_fingerprint: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n\tmessages: Message[];\n\tllmKey?: string;\n\tname?: string;\n}\n\nexport interface RunResponseStream {\n\tstream: ReadableStream<any>;\n\tthreadId: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n}\n\n// Union type for RunOptions\nexport type RunOptions =\n\t| (RunOptionsT & {name: string; apiKey?: never})\n\t| (RunOptionsT & {name?: never; apiKey: string});\n\nexport type RunOptionsStream =\n\t| (RunOptionsStreamT & {name: string; apiKey?: never})\n\t| (RunOptionsStreamT & {name?: never; apiKey: string});\n\nexport interface Function {\n\tname: string;\n\targuments: string;\n}\n\nexport interface ToolCall {\n\tid: string;\n\ttype: 'function';\n\tfunction: Function;\n}\n\nexport interface Message {\n\trole: Role;\n\tcontent: string | null;\n\tname?: string;\n\ttool_call_id?: string;\n\ttool_calls?: ToolCall[];\n}\n\nexport interface ThreadMessage extends Message {\n\tattachments?: any[];\n\tmetadata?: Record<string, string>;\n}\n\nexport interface Variable {\n\tname: string;\n\tvalue: string;\n}\n\ninterface ToolChoice {\n\ttype: 'function';\n\tfunction: {name: string};\n}\n\ninterface Tools {\n\ttype: 'function';\n\tfunction: {\n\t\tname: string;\n\t\tdescription?: string;\n\t\tparameters?: Record<string, any>;\n\t};\n}\n\ninterface PipeBaseOptions {\n\tname: string;\n\tdescription?: string;\n\tstatus?: 'public' | 'private';\n\tupsert?: boolean;\n\tmodel?: string;\n\tstream?: boolean;\n\tjson?: boolean;\n\tstore?: boolean;\n\tmoderate?: boolean;\n\ttop_p?: number;\n\tmax_tokens?: number;\n\ttemperature?: number;\n\tpresence_penalty?: number;\n\tfrequency_penalty?: number;\n\tstop?: string[];\n\ttools?: Tools[];\n\ttool_choice?: 'auto' | 'required' | ToolChoice;\n\tparallel_tool_calls?: boolean;\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tmemory?: {\n\t\tname: string;\n\t}[];\n}\n\nexport interface PipeListResponse {\n\tname: string;\n\tdescription: string;\n\tstatus: 'public' | 'private';\n\towner_login: string;\n\turl: string;\n\tmodel: string;\n\tstream: boolean;\n\tjson: boolean;\n\tstore: boolean;\n\tmoderate: boolean;\n\ttop_p: number;\n\tmax_tokens: number;\n\ttemperature: number;\n\tpresence_penalty: number;\n\tfrequency_penalty: number;\n\tstop: string[];\n\ttool_choice: 'auto' | 'required' | ToolChoice;\n\tparallel_tool_calls: boolean;\n\tmessages: Message[];\n\tvariables: Variable[] | [];\n\ttools: Tools[] | [];\n\tmemory:\n\t\t| {\n\t\t\t\tname: string;\n\t\t  }[]\n\t\t| [];\n}\n\ninterface PipeBaseResponse {\n\tname: string;\n\tdescription: string;\n\tstatus: 'public' | 'private';\n\towner_login: string;\n\turl: string;\n\ttype: 'chat' | 'generate' | 'run';\n\tapi_key: string;\n}\n\nexport interface PipeCreateOptions extends PipeBaseOptions {}\nexport interface PipeUpdateOptions extends PipeBaseOptions {}\nexport interface PipeCreateResponse extends PipeBaseResponse {}\nexport interface PipeUpdateResponse extends PipeBaseResponse {}\n\ninterface MemoryBaseResponse {\n\tname: string;\n\tdescription: string;\n\towner_login: string;\n\turl: string;\n}\n\nexport type EmbeddingModels =\n\t| 'openai:text-embedding-3-large'\n\t| 'cohere:embed-multilingual-v3.0'\n\t| 'cohere:embed-multilingual-light-v3.0'\n\t| 'google:text-embedding-004';\n\nexport type ContentType =\n\t| 'application/pdf'\n\t| 'text/plain'\n\t| 'text/markdown'\n\t| 'text/csv'\n\t| 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t| 'application/vnd.ms-excel';\n\nexport interface MemoryCreateOptions {\n\tname: string;\n\tdescription?: string;\n\tembedding_model?: EmbeddingModels;\n}\n\nexport interface MemoryDeleteOptions {\n\tname: string;\n}\n\ntype FilterOperator = 'Eq' | 'NotEq' | 'In' | 'NotIn' | 'And' | 'Or';\ntype FilterConnective = 'And' | 'Or';\ntype FilterValue = string | string[];\ntype MemoryFilters = [\n\tFilterOperator | FilterConnective,\n\tFilterValue | MemoryFilters,\n][];\n\nexport interface MemoryRetrieveOptions {\n\tquery: string;\n\tmemory: {\n\t\tname: string;\n\t\tfilters?: MemoryFilters;\n\t}[];\n\ttopK?: number;\n}\n\nexport interface MemoryListDocOptions {\n\tmemoryName: string;\n}\n\nexport interface MemoryDeleteDocOptions {\n\tmemoryName: string;\n\tdocumentName: string;\n}\n\nexport interface MemoryUploadDocOptions {\n\tmemoryName: string;\n\tdocumentName: string;\n\tmeta?: Record<string, string>;\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tcontentType: ContentType;\n}\n\nexport interface MemoryRetryDocEmbedOptions {\n\tmemoryName: string;\n\tdocumentName: string;\n}\n\nexport interface MemoryCreateResponse extends MemoryBaseResponse {\n\tembedding_model: EmbeddingModels;\n}\nexport interface MemoryListResponse extends MemoryBaseResponse {\n\tembedding_model: EmbeddingModels;\n}\nexport interface BaseDeleteResponse {\n\tsuccess: boolean;\n}\n\nexport interface MemoryDeleteResponse extends BaseDeleteResponse {}\nexport interface MemoryDeleteDocResponse extends BaseDeleteResponse {}\nexport interface MemoryRetryDocEmbedResponse extends BaseDeleteResponse {}\n\nexport interface MemoryRetrieveResponse {\n\ttext: string;\n\tsimilarity: number;\n\tmeta: Record<string, string>;\n}\n\nexport interface MemoryListDocResponse {\n\tname: string;\n\tstatus: 'queued' | 'in_progress' | 'completed' | 'failed';\n\tstatus_message: string | null;\n\tmetadata: {\n\t\tsize: number;\n\t\ttype: ContentType;\n\t};\n\tenabled: boolean;\n\tchunk_size: number;\n\tchunk_overlap: number;\n\towner_login: string;\n}\n\nexport interface LangbaseOptions {\n\tapiKey: string;\n\tbaseUrl?: 'https://api.langbase.com' | 'https://eu-api.langbase.com';\n}\n\nexport interface ToolWebSearchOptions {\n\tquery: string;\n\tservice: 'exa';\n\ttotalResults?: number;\n\tdomains?: string[];\n\tapiKey?: string;\n}\n\nexport interface ToolWebSearchResponse {\n\turl: string;\n\tcontent: string;\n}\n\nexport interface ToolCrawlOptions {\n\turl: string[];\n\tmaxPages?: number;\n\tapiKey?: string;\n}\n\nexport interface ToolCrawlResponse {\n\turl: string;\n\tcontent: string;\n}\n\nexport interface EmbedOptions {\n\tchunks: string[];\n\tembeddingModel?: EmbeddingModels;\n}\n\nexport type EmbedResponse = number[][];\n\nexport interface ChunkOptions {\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tdocumentName: string;\n\tcontentType: ContentType;\n\tchunkMaxLength?: string;\n\tchunkOverlap?: string;\n\tseparator?: string;\n}\n\nexport type ChunkResponse = string[];\n\nexport type ParseOptions = {\n\tdocument: Buffer | File | FormData | ReadableStream;\n\tdocumentName: string;\n\tcontentType: ContentType;\n};\n\nexport type ParseResponse = {\n\tdocumentName: string;\n\tcontent: string;\n};\n\nexport interface ThreadsCreate {\n\tthreadId?: string;\n\tmetadata?: Record<string, string>;\n\tmessages?: ThreadMessage[];\n}\n\nexport interface ThreadsUpdate {\n\tthreadId: string;\n\tmetadata: Record<string, string>;\n}\n\nexport interface ThreadsGet {\n\tthreadId: string;\n}\n\nexport interface DeleteThreadOptions {\n\tthreadId: string;\n}\n\nexport interface ThreadsBaseResponse {\n\tid: string;\n\tobject: 'thread';\n\tcreated_at: number;\n\tmetadata: Record<string, string>;\n}\n\nexport interface ThreadMessagesCreate {\n\tthreadId: string;\n\tmessages: ThreadMessage[];\n}\n\nexport interface ThreadMessagesList {\n\tthreadId: string;\n}\n\nexport interface ThreadMessagesBaseResponse extends ThreadMessage {\n\tid: string;\n\tcreated_at: number;\n\tthread_id: string;\n}\n\nexport class Langbase {\n\tprivate request: Request;\n\tprivate apiKey: string;\n\tprivate baseUrl: string;\n\tpublic pipes: {\n\t\tlist: () => Promise<PipeListResponse[]>;\n\t\tcreate: (options: PipeCreateOptions) => Promise<PipeCreateResponse>;\n\t\tupdate: (options: PipeUpdateOptions) => Promise<PipeUpdateResponse>;\n\t\trun: {\n\t\t\t(options: RunOptionsStream): Promise<RunResponseStream>;\n\t\t\t(options: RunOptions): Promise<RunResponse>;\n\t\t};\n\t};\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.pipes`\n\t */\n\tpublic pipe: {\n\t\tlist: () => Promise<PipeListResponse[]>;\n\t\tcreate: (options: PipeCreateOptions) => Promise<PipeCreateResponse>;\n\t\tupdate: (options: PipeUpdateOptions) => Promise<PipeUpdateResponse>;\n\t\trun: {\n\t\t\t(options: RunOptionsStream): Promise<RunResponseStream>;\n\t\t\t(options: RunOptions): Promise<RunResponse>;\n\t\t};\n\t};\n\n\tpublic memories: {\n\t\tcreate: (options: MemoryCreateOptions) => Promise<MemoryCreateResponse>;\n\t\tdelete: (options: MemoryDeleteOptions) => Promise<MemoryDeleteResponse>;\n\t\tretrieve: (\n\t\t\toptions: MemoryRetrieveOptions,\n\t\t) => Promise<MemoryRetrieveResponse[]>;\n\t\tlist: () => Promise<MemoryListResponse[]>;\n\t\tdocuments: {\n\t\t\tlist: (\n\t\t\t\toptions: MemoryListDocOptions,\n\t\t\t) => Promise<MemoryListDocResponse[]>;\n\t\t\tdelete: (\n\t\t\t\toptions: MemoryDeleteDocOptions,\n\t\t\t) => Promise<MemoryDeleteDocResponse>;\n\t\t\tupload: (options: MemoryUploadDocOptions) => Promise<Response>;\n\t\t\tembeddings: {\n\t\t\t\tretry: (\n\t\t\t\t\toptions: MemoryRetryDocEmbedOptions,\n\t\t\t\t) => Promise<MemoryRetryDocEmbedResponse>;\n\t\t\t};\n\t\t};\n\t};\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.memories`\n\t */\n\tpublic memory: {\n\t\tcreate: (options: MemoryCreateOptions) => Promise<MemoryCreateResponse>;\n\t\tdelete: (options: MemoryDeleteOptions) => Promise<MemoryDeleteResponse>;\n\t\tretrieve: (\n\t\t\toptions: MemoryRetrieveOptions,\n\t\t) => Promise<MemoryRetrieveResponse[]>;\n\t\tlist: () => Promise<MemoryListResponse[]>;\n\t\tdocuments: {\n\t\t\tlist: (\n\t\t\t\toptions: MemoryListDocOptions,\n\t\t\t) => Promise<MemoryListDocResponse[]>;\n\t\t\tdelete: (\n\t\t\t\toptions: MemoryDeleteDocOptions,\n\t\t\t) => Promise<MemoryDeleteDocResponse>;\n\t\t\tupload: (options: MemoryUploadDocOptions) => Promise<Response>;\n\t\t\tembedding: {\n\t\t\t\tretry: (\n\t\t\t\t\toptions: MemoryRetryDocEmbedOptions,\n\t\t\t\t) => Promise<MemoryRetryDocEmbedResponse>;\n\t\t\t};\n\t\t};\n\t};\n\n\tpublic threads: {\n\t\tcreate: (options: ThreadsCreate) => Promise<ThreadsBaseResponse>;\n\t\tupdate: (options: ThreadsUpdate) => Promise<ThreadsBaseResponse>;\n\t\tget: (options: ThreadsGet) => Promise<ThreadsBaseResponse>;\n\t\tdelete: (options: DeleteThreadOptions) => Promise<{success: boolean}>;\n\t\tappend: (\n\t\t\toptions: ThreadMessagesCreate,\n\t\t) => Promise<ThreadMessagesBaseResponse[]>;\n\t\tmessages: {\n\t\t\tlist: (\n\t\t\t\toptions: ThreadMessagesList,\n\t\t\t) => Promise<ThreadMessagesBaseResponse[]>;\n\t\t};\n\t};\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.tools`\n\t */\n\tpublic tool: {\n\t\tcrawl: (options: ToolCrawlOptions) => Promise<ToolCrawlResponse[]>;\n\t\twebSearch: (\n\t\t\toptions: ToolWebSearchOptions,\n\t\t) => Promise<ToolWebSearchResponse[]>;\n\t};\n\n\tpublic tools: {\n\t\tcrawl: (options: ToolCrawlOptions) => Promise<ToolCrawlResponse[]>;\n\t\twebSearch: (\n\t\t\toptions: ToolWebSearchOptions,\n\t\t) => Promise<ToolWebSearchResponse[]>;\n\t};\n\n\tpublic embed: (options: EmbedOptions) => Promise<EmbedResponse>;\n\tpublic chunk: (options: ChunkOptions) => Promise<ChunkResponse>;\n\tpublic parse: (options: ParseOptions) => Promise<ParseResponse>;\n\n\tconstructor(options?: LangbaseOptions) {\n\t\tthis.baseUrl = options?.baseUrl ?? 'https://api.langbase.com';\n\t\tthis.apiKey = options?.apiKey ?? '';\n\t\tthis.request = new Request({\n\t\t\tapiKey: this.apiKey,\n\t\t\tbaseUrl: this.baseUrl,\n\t\t});\n\n\t\t// Initialize pipe property with method bindings\n\t\tthis.pipe = {\n\t\t\tlist: this.listPipe.bind(this),\n\t\t\tcreate: this.createPipe.bind(this),\n\t\t\tupdate: this.updatePipe.bind(this),\n\t\t\trun: this.runPipe.bind(this),\n\t\t};\n\n\t\tthis.pipes = {\n\t\t\tlist: this.listPipe.bind(this),\n\t\t\tcreate: this.createPipe.bind(this),\n\t\t\tupdate: this.updatePipe.bind(this),\n\t\t\trun: this.runPipe.bind(this),\n\t\t};\n\n\t\t// Initialize memory property with method bindings\n\t\tthis.memory = {\n\t\t\tcreate: this.createMemory.bind(this),\n\t\t\tdelete: this.deleteMemory.bind(this),\n\t\t\tretrieve: this.retrieveMemory.bind(this),\n\t\t\tlist: this.listMemory.bind(this),\n\t\t\tdocuments: {\n\t\t\t\tlist: this.listDocs.bind(this),\n\t\t\t\tdelete: this.deleteDoc.bind(this),\n\t\t\t\tupload: this.uploadDocs.bind(this),\n\t\t\t\tembedding: {\n\t\t\t\t\tretry: this.retryDocEmbed.bind(this),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\t// Initialize memory property with method bindings\n\t\tthis.memories = {\n\t\t\tcreate: this.createMemory.bind(this),\n\t\t\tdelete: this.deleteMemory.bind(this),\n\t\t\tretrieve: this.retrieveMemory.bind(this),\n\t\t\tlist: this.listMemory.bind(this),\n\t\t\tdocuments: {\n\t\t\t\tlist: this.listDocs.bind(this),\n\t\t\t\tdelete: this.deleteDoc.bind(this),\n\t\t\t\tupload: this.uploadDocs.bind(this),\n\t\t\t\tembeddings: {\n\t\t\t\t\tretry: this.retryDocEmbed.bind(this),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.tools = {\n\t\t\tcrawl: this.webCrawl.bind(this),\n\t\t\twebSearch: this.webSearch.bind(this),\n\t\t};\n\n\t\tthis.tool = {\n\t\t\tcrawl: this.webCrawl.bind(this),\n\t\t\twebSearch: this.webSearch.bind(this),\n\t\t};\n\n\t\tthis.embed = this.generateEmbeddings.bind(this);\n\t\tthis.chunk = this.chunkDocument.bind(this);\n\t\tthis.parse = this.parseDocument.bind(this);\n\t\tthis.threads = {\n\t\t\tcreate: this.createThread.bind(this),\n\t\t\tupdate: this.updateThread.bind(this),\n\t\t\tget: this.getThread.bind(this),\n\t\t\tdelete: this.deleteThread.bind(this),\n\t\t\tappend: this.appendThreadMessages.bind(this),\n\t\t\tmessages: {\n\t\t\t\tlist: this.listThreadMessages.bind(this),\n\t\t\t},\n\t\t};\n\t}\n\n\tprivate async runPipe(\n\t\toptions: RunOptionsStream,\n\t): Promise<RunResponseStream>;\n\tprivate async runPipe(options: RunOptions): Promise<RunResponse>;\n\tprivate async runPipe(\n\t\toptions: RunOptions | RunOptionsStream,\n\t): Promise<RunResponse | RunResponseStream> {\n\t\tif (!options.name?.trim() && !options.apiKey) {\n\t\t\tthrow new Error(\n\t\t\t\t'Pipe name or Pipe API key is required to run the pipe.',\n\t\t\t);\n\t\t}\n\n\t\t// Remove stream property if it's not set to true\n\t\tif (typeof options.stream === 'undefined') {\n\t\t\tdelete options.stream;\n\t\t}\n\n\t\t// if apikey is provided, create a new request instance\n\t\tif (options.apiKey) {\n\t\t\tthis.request = new Request({\n\t\t\t\tapiKey: options.apiKey,\n\t\t\t\tbaseUrl: this.baseUrl,\n\t\t\t});\n\t\t}\n\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/pipes/run',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t...(options.llmKey && {\n\t\t\t\t\t'LB-LLM-KEY': options.llmKey,\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new pipe on Langbase.\n\t *\n\t * @param {PipeCreateOptions} options - The options for creating the pipe.\n\t * @returns {Promise<PipeCreateResponse>} A promise that resolves to the response of the pipe creation.\n\t */\n\tprivate async createPipe(\n\t\toptions: PipeCreateOptions,\n\t): Promise<PipeCreateResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/pipes',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Updates a pipe on Langbase.\n\t *\n\t * @param {PipeUpdateOptions} options - The options for updating the pipe.\n\t * @returns {Promise<PipeUpdateResponse>} A promise that resolves to the response of the update operation.\n\t */\n\tprivate async updatePipe(\n\t\toptions: PipeUpdateOptions,\n\t): Promise<PipeUpdateResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: `/v1/pipes/${options.name}`,\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a list of pipes.\n\t *\n\t * @returns {Promise<PipeListResponse[]>} A promise that resolves to an array of PipeListResponse objects.\n\t */\n\tprivate async listPipe(): Promise<PipeListResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: '/v1/pipes',\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new memory on Langbase.\n\t *\n\t * @param {MemoryCreateOptions} options - The options to create the memory instance.\n\t * @param {string} options.name - The name of the memory.\n\t * @param {string} options.description - The description of the memory.\n\t * @returns {Promise<MemoryCreateResponse>} A promise that resolves to the response of the memory creation.\n\t */\n\tprivate async createMemory(\n\t\toptions: MemoryCreateOptions,\n\t): Promise<MemoryCreateResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/memory',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a list of all memories on Langbase.\n\t *\n\t * @returns {Promise<MemoryListResponse[]>} A promise that resolves to an array of memory list responses.\n\t */\n\tprivate async listMemory(): Promise<MemoryListResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: '/v1/memory',\n\t\t});\n\t}\n\n\t/**\n\t * Deletes a memory on Langbase.\n\t *\n\t * @param {MemoryDeleteOptions} options - The options for deleting the memory resource.\n\t * @param {string} options.name - The name of the memory to delete.\n\t * @returns {Promise<MemoryDeleteResponse>} A promise that resolves to the response of the delete operation.\n\t */\n\tprivate async deleteMemory(\n\t\toptions: MemoryDeleteOptions,\n\t): Promise<MemoryDeleteResponse> {\n\t\treturn this.request.delete({\n\t\t\tendpoint: `/v1/memory/${options.name}`,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves similar text from the memory.\n\t *\n\t * @param {MemoryRetrieveOptions} options - The options to use for retrieving memory data.\n\t * @param {string} options.query - The query text to search for.\n\t * @param {object[]} options.memory - The memory to search in.\n\t * @param {number} [options.topK] - The number of similar texts to retrieve.\n\t * @returns A promise that resolves to an array of `MemoryRetrieveResponse` objects.\n\t */\n\tprivate async retrieveMemory(\n\t\toptions: MemoryRetrieveOptions,\n\t): Promise<MemoryRetrieveResponse[]> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/memory/retrieve',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a list of documents inside a memory.\n\t *\n\t * @param {MemoryListDocOptions} options - The options for listing documents, including the memory name.\n\t * @param {string} options.memoryName - The name of the memory to list documents from.\n\t * @returns A promise that resolves to an array of `MemoryListDocResponse` objects.\n\t */\n\tprivate async listDocs(\n\t\toptions: MemoryListDocOptions,\n\t): Promise<MemoryListDocResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/memory/${options.memoryName}/documents`,\n\t\t});\n\t}\n\n\t/**\n\t * Deletes a document from a memory.\n\t *\n\t * @param {MemoryDeleteDocOptions} options - The options for deleting the document.\n\t * @param {string} options.memoryName - The name of the memory to delete the document from.\n\t * @param {string} options.documentName - The name of the document to delete.\n\t * @returns A promise that resolves to a `MemoryDeleteDocResponse` indicating the result of the delete operation.\n\t */\n\tprivate async deleteDoc(\n\t\toptions: MemoryDeleteDocOptions,\n\t): Promise<MemoryDeleteDocResponse> {\n\t\treturn this.request.delete({\n\t\t\tendpoint: `/v1/memory/${options.memoryName}/documents/${options.documentName}`,\n\t\t});\n\t}\n\n\t/**\n\t * Uploads a document to the memory.\n\t *\n\t * @param {MemoryUploadDocOptions} options - The options for uploading the document.\n\t * @param {string} options.memoryName - The name of the memory to upload the document to.\n\t * @param {string} options.fileName - The name of the file being uploaded.\n\t * @param {object} [options.meta] - Optional metadata associated with the document.\n\t * @param {string} options.contentType - The MIME type of the file being uploaded.\n\t * @param {Blob | Buffer} options.file - The file content to be uploaded.\n\t * @returns {Promise<Response>} The response from the upload request.\n\t * @throws Will throw an error if the upload fails.\n\t */\n\tprivate async uploadDocs(\n\t\toptions: MemoryUploadDocOptions,\n\t): Promise<Response> {\n\t\ttry {\n\t\t\tconst response = (await this.request.post({\n\t\t\t\tendpoint: `/v1/memory/documents`,\n\t\t\t\tbody: {\n\t\t\t\t\tmemoryName: options.memoryName,\n\t\t\t\t\tfileName: options.documentName,\n\t\t\t\t\tmeta: options.meta,\n\t\t\t\t},\n\t\t\t})) as unknown as {signedUrl: string};\n\n\t\t\tconst uploadUrl = response.signedUrl;\n\n\t\t\treturn await fetch(uploadUrl, {\n\t\t\t\tmethod: 'PUT',\n\t\t\t\theaders: {\n\t\t\t\t\tAuthorization: `Bearer ${this.apiKey}`,\n\t\t\t\t\t'Content-Type': options.contentType,\n\t\t\t\t},\n\t\t\t\tbody: options.document,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Retries the embedding process for a specific document in memory.\n\t *\n\t * @param options - The options required to retry the document embedding.\n\t * @param options.memoryName - The name of the memory containing the document.\n\t * @param options.documentName - The name of the document to retry embedding for.\n\t * @returns A promise that resolves to the response of the retry operation.\n\t */\n\tprivate async retryDocEmbed(\n\t\toptions: MemoryRetryDocEmbedOptions,\n\t): Promise<MemoryRetryDocEmbedResponse> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/memory/${options.memoryName}/documents/${options.documentName}/embeddings/retry`,\n\t\t});\n\t}\n\n\t/**\n\t * Performs a web search using the Langbase API.\n\t *\n\t * @param options - Web search configuration options\n\t * @param options.apiKey - Optional API key for web search authentication\n\t * @returns Promise that resolves to an array of web search results\n\t */\n\tprivate async webSearch(\n\t\toptions: ToolWebSearchOptions,\n\t): Promise<ToolWebSearchResponse[]> {\n\t\tconst apiKey = options.apiKey ? options.apiKey : null;\n\t\tapiKey && delete options.apiKey;\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/tools/web-search',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t...(apiKey && {\n\t\t\t\t\t'LB-WEB-SEARCH-KEY': apiKey,\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Performs a web crawls on target websites using the Langbase API.\n\t *\n\t * @param options - Crawl configuration options\n\t * @returns An array of responses containing data from the crawl operation.\n\t */\n\tprivate async webCrawl(\n\t\toptions: ToolCrawlOptions,\n\t): Promise<ToolCrawlResponse[]> {\n\t\tconst apiKey = options.apiKey ? options.apiKey : null;\n\t\tapiKey && delete options.apiKey;\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/tools/crawl',\n\t\t\tbody: options,\n\t\t\theaders: {\n\t\t\t\t...(apiKey && {\n\t\t\t\t\t'LB-CRAWL-KEY': apiKey,\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Generates embeddings for the given input using the LangBase API.\n\t *\n\t * @param options - Embed options\n\t * @returns Promise that resolves to the embedding response containing vector representations\n\t */\n\tprivate async generateEmbeddings(\n\t\toptions: EmbedOptions,\n\t): Promise<EmbedResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/embed',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Splits a given document into multiple chunks using the Langbase API.\n\t *\n\t * @param options - The chunking options.\n\t * @param options.document - The document to be chunked.\n\t * @param options.chunk_max_length - An optional maximum length for each chunk.\n\t * @param options.chunk_overlap - An optional number of overlapping characters between chunks.\n\t * @param options.separator - An optional separator used to split the document.\n\t * @returns A promise that resolves to the chunked document response.\n\t */\n\tprivate async chunkDocument(options: ChunkOptions): Promise<ChunkResponse> {\n\t\tconst formData = await convertDocToFormData({\n\t\t\tdocument: options.document,\n\t\t\tdocumentName: options.documentName,\n\t\t\tcontentType: options.contentType,\n\t\t});\n\n\t\tif (options.chunkMaxLength)\n\t\t\tformData.append('chunkMaxLength', options.chunkMaxLength);\n\t\tif (options.chunkOverlap)\n\t\t\tformData.append('chunkOverlap', options.chunkOverlap);\n\t\tif (options.separator) formData.append('separator', options.separator);\n\n\t\tconst response = await fetch(`${this.baseUrl}/v1/chunk`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${this.apiKey}`,\n\t\t\t},\n\t\t\tbody: formData,\n\t\t});\n\n\t\treturn response.json();\n\t}\n\n\t/**\n\t * Parses a document using the Langbase API.\n\t *\n\t * @param options - The options for parsing the document\n\t * @param options.document - The document to be parsed\n\t * @param options.documentName - The name of the document\n\t * @param options.contentType - The content type of the document\n\t *\n\t * @returns A promise that resolves to the parse response from the API\n\t *\n\t * @throws {Error} If the API request fails\n\t */\n\tprivate async parseDocument(options: ParseOptions): Promise<ParseResponse> {\n\t\tconst formData = await convertDocToFormData({\n\t\t\tdocument: options.document,\n\t\t\tdocumentName: options.documentName,\n\t\t\tcontentType: options.contentType,\n\t\t});\n\n\t\tconst response = await fetch(`${this.baseUrl}/v1/parse`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tAuthorization: `Bearer ${this.apiKey}`,\n\t\t\t},\n\t\t\tbody: formData,\n\t\t});\n\n\t\treturn response.json();\n\t}\n\n\t/**\n\t * Creates a new thread with specified options.\n\t * @param {ThreadsCreate} options - The options object containing thread creation parameters.\n\t * @returns {Promise<ThreadsBaseResponse>} A promise that resolves to the created thread response.\n\t * @private\n\t */\n\tprivate async createThread(\n\t\toptions: ThreadsCreate,\n\t): Promise<ThreadsBaseResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: '/v1/threads',\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Updates an existing thread with the provided options.\n\t *\n\t * @param options - The options to update the thread with\n\t * @param options.threadId - The ID of the thread to update\n\t * @returns A promise that resolves to the updated thread response\n\t * @throws {Error} If the request fails\n\t */\n\tprivate async updateThread(\n\t\toptions: ThreadsUpdate,\n\t): Promise<ThreadsBaseResponse> {\n\t\treturn this.request.post({\n\t\t\tendpoint: `/v1/threads/${options.threadId}`,\n\t\t\tbody: options,\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves a thread by its ID.\n\t * @param {ThreadsGet} options - The options object containing the thread ID.\n\t * @param {string} options.threadId - The unique identifier of the thread to retrieve.\n\t * @returns {Promise<ThreadsBaseResponse>} A promise that resolves to the thread data.\n\t */\n\tprivate async getThread(options: ThreadsGet): Promise<ThreadsBaseResponse> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/threads/${options.threadId}`,\n\t\t});\n\t}\n\n\tprivate async deleteThread(\n\t\toptions: DeleteThreadOptions,\n\t): Promise<{success: boolean}> {\n\t\treturn this.request.delete({\n\t\t\tendpoint: `/v1/threads/${options.threadId}`,\n\t\t});\n\t}\n\n\tprivate async appendThreadMessages(\n\t\toptions: ThreadMessagesCreate,\n\t): Promise<ThreadMessagesBaseResponse[]> {\n\t\treturn this.request.post({\n\t\t\tendpoint: `/v1/threads/${options.threadId}/messages`,\n\t\t\tbody: options.messages,\n\t\t});\n\t}\n\n\tprivate async listThreadMessages(\n\t\toptions: ThreadMessagesList,\n\t): Promise<ThreadMessagesBaseResponse[]> {\n\t\treturn this.request.get({\n\t\t\tendpoint: `/v1/threads/${options.threadId}/messages`,\n\t\t});\n\t}\n}\n","import {Message, Role, ToolCall, Usage, Variable} from '@/langbase/langbase';\nimport {Request} from '../common/request';\nimport {Stream} from '../common/stream';\n\nexport interface GenerateOptions {\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tthreadId?: string;\n\tchat?: boolean;\n}\n\nexport interface StreamOptions {\n\tmessages?: Message[];\n\tvariables?: Variable[];\n\tthreadId?: string | null;\n\tchat?: boolean;\n}\n\ninterface ChoiceGenerate {\n\tindex: number;\n\tmessage: Message;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\ninterface ChoiceStream {\n\tindex: number;\n\tdelta: Delta;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\ninterface Delta {\n\trole?: Role;\n\tcontent?: string;\n\ttool_calls?: ToolCall[];\n}\n\nexport interface GenerateResponse {\n\tcompletion: string;\n\tthreadId?: string;\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceGenerate[];\n\tusage: Usage;\n\tsystem_fingerprint: string | null;\n}\n\nexport type StreamText = Stream<StreamChunk>;\n\nexport interface StreamResponse {\n\tstream: StreamText;\n\tthreadId: string | null;\n}\n\nexport interface StreamChunk {\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceStream[];\n}\n\nexport interface PipeOptions {\n\tapiKey: string;\n\tbaseUrl?: string;\n\tname?: string;\n}\n\nexport class Pipe {\n\tprivate request: Request;\n\n\tconstructor(options: PipeOptions) {\n\t\tconst baseUrl = 'https://api.langbase.com';\n\t\tthis.request = new Request({apiKey: options.apiKey, baseUrl});\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.pipes.run()` instead\n\t * @see https://langbase.com/docs/sdk/pipe/run\n\t */\n\tasync generateText(options: GenerateOptions): Promise<GenerateResponse> {\n\t\treturn this.request.post<GenerateResponse>({\n\t\t\tendpoint: options.chat ? '/beta/chat' : '/beta/generate',\n\t\t\tbody: {...options, stream: false},\n\t\t});\n\t}\n\n\t/**\n\t * @deprecated This method is deprecated and will be removed in a future version.\n\t *\n\t * Please use `langbase.pipes.run()` instead\n\t * @see https://langbase.com/docs/sdk/pipe/run\n\t */\n\tasync streamText(options: StreamOptions): Promise<StreamResponse> {\n\t\treturn this.request.post<StreamResponse>({\n\t\t\tendpoint: options.chat ? '/beta/chat' : '/beta/generate',\n\t\t\tbody: {...options, stream: true},\n\t\t});\n\t}\n}\n\n/**\n * Print stream to standard output (console).\n * @param stream The stream to print\n */\nexport const printStreamToStdout = async (\n\tstream: StreamText,\n): Promise<void> => {\n\tfor await (const chunk of stream) {\n\t\tconst textPart = chunk.choices[0]?.delta?.content || '';\n\t\tprocess.stdout.write(textPart);\n\t}\n};\n","import {ChatCompletionStream} from 'openai/lib/ChatCompletionStream';\nimport {Stream} from 'openai/streaming';\nimport {ChatCompletionMessageToolCall} from 'openai/resources/chat/completions';\nimport {RunResponse, RunResponseStream} from '@/langbase/langbase';\n\nexport interface Runner extends ChatCompletionStream {}\n\nexport interface ToolCallResult extends ChatCompletionMessageToolCall {}\n\nexport type MessageRole = 'function' | 'assistant' | 'system' | 'user' | 'tool';\n\ninterface Delta {\n\trole?: MessageRole;\n\tcontent?: string;\n\ttool_calls?: ToolCallResult[];\n}\n\ninterface ChoiceStream {\n\tindex: number;\n\tdelta: Delta;\n\tlogprobs: boolean | null;\n\tfinish_reason: string;\n}\n\nexport interface ChunkStream {\n\tid: string;\n\tobject: string;\n\tcreated: number;\n\tmodel: string;\n\tchoices: ChoiceStream[];\n}\n\n/**\n * Converts a ReadableStream into a Runner.\n *\n * @param readableStream - The ReadableStream to convert.\n * @returns The converted Runner.\n */\nexport const fromReadableStream = (readableStream: ReadableStream): Runner => {\n\treturn ChatCompletionStream.fromReadableStream(readableStream);\n};\n\n/**\n * Returns a runner for the given readable stream.\n *\n * @param readableStream - The readable stream to create a runner for.\n * @returns A runner for the given readable stream.\n */\nexport const getRunner = (readableStream: ReadableStream) => {\n\treturn fromReadableStream(readableStream);\n};\n\n/**\n * Retrieves the text part from a given ChunkStream.\n *\n * @param chunk - The ChunkStream object.\n * @returns The text content of the first choice's delta, or an empty string if it doesn't exist.\n */\nexport const getTextPart = (chunk: ChunkStream) => {\n\treturn chunk.choices[0]?.delta?.content || '';\n};\n\n/**\n * Handles the response stream from a given `Response` object.\n *\n * @param {Object} params - The parameters for handling the response stream.\n * @param {Response} params.response - The API response to handle.\n * @param {boolean} params.rawResponse - Optional flag to include raw response headers.\n *\n * @returns {Object} An object containing the processed stream, thread ID, and optionally raw response headers.\n * @returns {ReadableStream<any>} return.stream - The readable stream created from the response.\n * @returns {string | null} return.threadId - The thread ID extracted from the response headers.\n * @returns {Object} [return.rawResponse] - Optional raw response headers.\n * @returns {Record<string, string>} return.rawResponse.headers - The headers from the raw response.\n */\nexport function handleResponseStream({\n\tresponse,\n\trawResponse,\n}: {\n\tresponse: Response;\n\trawResponse?: boolean;\n}): {\n\tstream: any;\n\tthreadId: string | null;\n\trawResponse?: {\n\t\theaders: Record<string, string>;\n\t};\n} {\n\tconst controller = new AbortController();\n\tconst streamSSE = Stream.fromSSEResponse(response, controller);\n\tconst stream = streamSSE.toReadableStream();\n\n\tconst result: {\n\t\tstream: ReadableStream<any>;\n\t\tthreadId: string | null;\n\t\trawResponse?: {\n\t\t\theaders: Record<string, string>;\n\t\t};\n\t} = {\n\t\tstream,\n\t\tthreadId: response.headers.get('lb-thread-id'),\n\t};\n\tif (rawResponse) {\n\t\tresult.rawResponse = {\n\t\t\theaders: Object.fromEntries(response.headers.entries()),\n\t\t};\n\t}\n\treturn result;\n}\n\n/**\n * Retrieves tool calls from a given readable stream.\n *\n * @param stream - The readable stream from which to extract tool calls.\n * @returns A promise that resolves to an array of `ToolCall` objects.\n */\nexport async function getToolsFromStream(\n\tstream: ReadableStream<any>,\n): Promise<ChatCompletionMessageToolCall[]> {\n\tlet run = getRunner(stream);\n\tconst {choices} = await run.finalChatCompletion();\n\tconst tools = choices[0].message.tool_calls;\n\treturn tools ?? [];\n}\n\n/**\n * Retrieves tools from a readable stream asynchronously.\n *\n * @param stream - The readable stream to extract tools from\n * @returns A promise that resolves with the tools extracted from the stream\n */\nexport async function getToolsFromRunStream(stream: ReadableStream<any>) {\n\treturn getToolsFromStream(stream);\n}\n\n/**\n * Extracts tool calls from non-stream response.\n * @param response - The run response object\n * @returns A promise that resolves to an array of tool calls. Returns empty array if no tools are present.\n */\nexport async function getToolsFromRun(\n\tresponse: RunResponse,\n): Promise<ChatCompletionMessageToolCall[]> {\n\tconst tools = response.choices[0].message.tool_calls;\n\treturn tools ?? [];\n}\n"],"mappings":"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","names":[]}